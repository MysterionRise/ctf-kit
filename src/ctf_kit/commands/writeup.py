"""
Generate writeup documentation for solved challenges.

Supports single-challenge writeups and competition-wide exports with
tool commands, findings, and flag captures.
"""

from datetime import UTC, datetime
from pathlib import Path
from typing import Annotated

from rich.console import Console
from rich.panel import Panel
import typer
import yaml

from ctf_kit.competition import (
    ChallengeEntry,
    find_competition_root,
    load_competition,
)

console = Console()

WRITEUP_TEMPLATE = """# {challenge_name}

## Challenge Info
- **Category**: {category}
- **Points**: {points}
- **Solved**: {solved_time}

## Description
> {description}

## TL;DR
{tldr}

## Solution

### Step 1: Initial Analysis
{analysis}

### Step 2: Solution
{solution}

## Flag
```text
{flag}
```

## Tools Used
{tools}

## Lessons Learned
{lessons}

---
*Generated by CTF Kit*
"""

COMPETITION_WRITEUP_HEADER = """# {competition_name} - Writeups

- **Date**: {date}
- **Challenges Solved**: {solved_count}/{total_count}
- **Total Points**: {total_points}

---

"""

CHALLENGE_SECTION_TEMPLATE = """## {challenge_name}

| Field | Value |
|-------|-------|
| Category | {category} |
| Points | {points} |
| Status | {status} |
| Time | {solve_time} |

### Flag
```text
{flag}
```

### Analysis
{analysis}

### Solution
{solution}

### Tools Used
{tools}

---

"""

# Maximum length for inline content
MAX_CONTENT_LENGTH = 500


def generate_writeup(
    path: Annotated[
        Path | None, typer.Argument(help="Challenge path (default: current directory)")
    ] = None,
    output_format: Annotated[
        str, typer.Option("--format", "-f", help="Output format: markdown, html")
    ] = "markdown",
    output: Annotated[Path | None, typer.Option("--output", "-o", help="Output file path")] = None,
    export_all: Annotated[
        bool, typer.Option("--all", "-a", help="Export all challenges in competition")
    ] = False,
) -> None:
    """
    Generate a writeup for a solved challenge or entire competition.

    Uses information from .ctf/ folder (analysis.md, approach.md, etc.)
    to create a comprehensive writeup with tool commands, findings, and flags.

    Examples:
        ctf writeup                    # Generate for current challenge
        ctf writeup --all              # Export all competition challenges
        ctf writeup --format html      # Generate HTML writeup
        ctf writeup -o writeup.md      # Specify output file
    """
    _ = output_format  # Reserved for future HTML support

    target_path = path or Path.cwd()

    if export_all:
        _export_competition(target_path, output)
        return

    _export_single_challenge(target_path, output)


def _export_single_challenge(target_path: Path, output: Path | None) -> None:
    """Generate writeup for a single challenge."""
    ctf_dir = target_path / ".ctf"

    if not ctf_dir.exists():
        console.print("[red]No .ctf/ folder found. Run 'ctf init' first.[/]")
        raise typer.Exit(1)

    challenge_name = target_path.name

    # Gather challenge metadata from challenge.yaml
    challenge_data = _load_challenge_yaml(ctf_dir)
    category = challenge_data.get("category", "")
    points = challenge_data.get("points", "?")

    # Read analysis.md if exists
    analysis_content = _read_file_safe(ctf_dir / "analysis.md")

    # Read approach.md if exists
    approach_content = _read_file_safe(ctf_dir / "approach.md")

    # Read attempts.md for tool command history
    attempts_content = _read_file_safe(ctf_dir / "attempts.md")

    # Check for flag.txt
    flag_file = target_path / "flag.txt"
    flag = flag_file.read_text().strip() if flag_file.exists() else "FLAG_NOT_FOUND"

    # If no flag in flag.txt, check challenge.yaml
    if flag == "FLAG_NOT_FOUND" and challenge_data.get("flag"):
        flag = challenge_data["flag"]

    # Collect solve scripts
    solution_code = _collect_solution_code(target_path)

    # Collect tools used from attempts and artifacts
    tools_section = _collect_tools_section(ctf_dir, attempts_content)

    # Detect category if not in challenge.yaml
    if not category:
        category = _detect_category(analysis_content)

    # Build solution section
    solution_parts = []
    if solution_code:
        solution_parts.append(solution_code)
    if approach_content:
        solution_parts.append(approach_content[:MAX_CONTENT_LENGTH])
    solution_section = (
        "\n\n".join(solution_parts) if solution_parts else "<!-- Add solution steps -->"
    )

    # Generate writeup
    writeup_content = WRITEUP_TEMPLATE.format(
        challenge_name=challenge_name,
        category=category,
        points=points,
        solved_time=datetime.now(tz=UTC).strftime("%Y-%m-%d %H:%M UTC"),
        description="<!-- Add challenge description -->",
        tldr="<!-- One-line summary of the solution -->",
        analysis=analysis_content[:MAX_CONTENT_LENGTH]
        if analysis_content
        else "<!-- Add analysis -->",
        solution=solution_section,
        flag=flag,
        tools=tools_section or "<!-- List tools used -->",
        lessons="<!-- What did you learn? -->",
    )

    # Determine output path
    output_path = output if output else ctf_dir / "writeup.md"

    # Write output
    output_path.write_text(writeup_content)

    # Truncate flag display for privacy
    flag_preview = flag[:20] + "..." if len(flag) > 20 else flag

    console.print(
        Panel(
            f"[green]Writeup generated![/]\n\n"
            f"Output: [cyan]{output_path}[/]\n"
            f"Flag: [green]{flag_preview}[/]\n\n"
            f"Edit the writeup to add:\n"
            f"  Challenge description\n"
            f"  Detailed solution steps\n"
            f"  Lessons learned",
            title="Writeup Generated",
        )
    )


def _export_competition(target_path: Path, output: Path | None) -> None:
    """Export writeups for all challenges in a competition."""
    comp_root = find_competition_root(target_path)
    comp = load_competition(target_path) if comp_root else None

    if not comp:
        console.print("[red]No competition found. Run 'ctf competition init' first.[/]")
        raise typer.Exit(1)

    # Build header
    content = COMPETITION_WRITEUP_HEADER.format(
        competition_name=comp.name,
        date=datetime.now(tz=UTC).strftime("%Y-%m-%d"),
        solved_count=comp.solved_count,
        total_count=len(comp.challenges),
        total_points=comp.total_points,
    )

    # Find challenge directories and generate sections
    challenges_written = 0
    for challenge in comp.challenges:
        section = _build_challenge_section(challenge, comp_root)  # type: ignore[arg-type]
        content += section
        challenges_written += 1

    content += f"\n---\n*Generated by CTF Kit - {comp.name}*\n"

    # Write output
    output_path = output if output else (comp_root or target_path) / "writeups.md"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)

    console.print(
        Panel(
            f"[green]Competition writeup exported![/]\n\n"
            f"Competition: [cyan]{comp.name}[/]\n"
            f"Challenges: [green]{challenges_written}[/]\n"
            f"Output: [cyan]{output_path}[/]",
            title="Writeup Export",
        )
    )


def _build_challenge_section(
    challenge: ChallengeEntry,
    comp_root: Path,
) -> str:
    """Build a writeup section for a single challenge within a competition export."""
    entry = challenge

    # Try to find the challenge directory
    challenge_dir = _find_challenge_dir(comp_root, entry.name)

    analysis = ""
    solution = ""
    tools = ""
    flag = entry.flag or "N/A"

    if challenge_dir:
        ctf_dir = challenge_dir / ".ctf"
        if ctf_dir.exists():
            analysis = _read_file_safe(ctf_dir / "analysis.md")
            approach = _read_file_safe(ctf_dir / "approach.md")
            attempts = _read_file_safe(ctf_dir / "attempts.md")
            solution = _collect_solution_code(challenge_dir) or approach[:MAX_CONTENT_LENGTH]
            tools = _collect_tools_section(ctf_dir, attempts)

        # Check for flag.txt
        flag_file = challenge_dir / "flag.txt"
        if flag_file.exists():
            flag = flag_file.read_text().strip()

    # Compute solve time
    solve_time = "-"
    if entry.solve_duration:
        total_secs = int(entry.solve_duration.total_seconds())
        hours, remainder = divmod(total_secs, 3600)
        minutes = remainder // 60
        solve_time = f"{hours}h{minutes:02d}m" if hours else f"{minutes}m"

    return CHALLENGE_SECTION_TEMPLATE.format(
        challenge_name=entry.name,
        category=entry.category or "Unknown",
        points=entry.points or "?",
        status=entry.status.value,
        solve_time=solve_time,
        flag=flag,
        analysis=analysis[:MAX_CONTENT_LENGTH] if analysis else "No analysis recorded.",
        solution=solution or "No solution recorded.",
        tools=tools or "No tools recorded.",
    )


def _find_challenge_dir(comp_root: Path, name: str) -> Path | None:
    """Find a challenge directory by name within the competition root."""
    # Direct child
    direct = comp_root / name
    if direct.is_dir():
        return direct

    # Search in category subdirectories
    for child in comp_root.iterdir():
        if child.is_dir() and not child.name.startswith("."):
            candidate = child / name
            if candidate.is_dir():
                return candidate

    return None


def _load_challenge_yaml(ctf_dir: Path) -> dict[str, str]:
    """Load challenge.yaml from a .ctf directory."""
    challenge_yaml = ctf_dir / "challenge.yaml"
    if not challenge_yaml.exists():
        return {}

    with challenge_yaml.open() as f:
        return yaml.safe_load(f) or {}


def _read_file_safe(path: Path) -> str:
    """Read a file's content, returning empty string if it doesn't exist."""
    if not path.exists():
        return ""
    try:
        return path.read_text()
    except OSError:
        return ""


def _collect_solution_code(target_path: Path) -> str:
    """Collect solution code from solve.* and exploit.* files."""
    solve_files = list(target_path.glob("solve.*")) + list(target_path.glob("exploit.*"))
    if not solve_files:
        return ""

    parts = []
    for sf in solve_files:
        try:
            ext = sf.suffix.lstrip(".")
            lang = ext if ext in ("py", "sh", "rb", "js", "c", "rs") else ""
            code = sf.read_text()
            parts.append(f"**{sf.name}**\n```{lang}\n{code}\n```")
        except OSError:
            parts.append(f"See: {sf.name}")

    return "\n\n".join(parts)


def _collect_tools_section(ctf_dir: Path, attempts_content: str) -> str:
    """Build a tools section from artifacts and attempts content."""
    tools: list[str] = []

    # Extract tool references from attempts.md
    if attempts_content:
        tool_keywords = [
            "binwalk",
            "volatility",
            "zsteg",
            "steghide",
            "exiftool",
            "sqlmap",
            "gobuster",
            "ffuf",
            "xortool",
            "hashcat",
            "john",
            "rsactftool",
            "bkcrack",
            "fcrackzip",
            "tshark",
            "foremost",
            "checksec",
            "ropgadget",
            "radare2",
            "ghidra",
            "sherlock",
            "theharvester",
            "pwntools",
            "gdb",
            "strings",
            "file",
        ]
        content_lower = attempts_content.lower()
        for tool in tool_keywords:
            if tool in content_lower:
                tools.append(tool)

    # Check artifacts directory for evidence of tool usage
    artifacts_dir = ctf_dir / "artifacts"
    if artifacts_dir.is_dir():
        artifact_files = list(artifacts_dir.iterdir())
        if artifact_files:
            tools.append(f"({len(artifact_files)} artifact(s) extracted)")

    if not tools:
        return ""

    return "\n".join(f"- {t}" for t in tools)


def _detect_category(content: str) -> str:
    """Detect challenge category from content."""
    content_lower = content.lower()

    category_keywords = {
        "Crypto": ["crypto"],
        "Forensics": ["forensics"],
        "Pwn": ["pwn", "binary"],
        "Web": ["web"],
        "Reversing": ["reverse"],
        "Steganography": ["stego"],
        "OSINT": ["osint"],
    }

    for category, keywords in category_keywords.items():
        if any(kw in content_lower for kw in keywords):
            return category

    return "Unknown"
